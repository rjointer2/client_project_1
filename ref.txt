const [frame, setFrame] = useState(0);
  const [rectangle, setRectangle] = useState({ x: 0, y: 0, height: 48, width: 48 });



  useLayoutEffect(() => {
    
      fetch('./api/socket').finally(() => {
        const socket = io();

        let context = document.querySelector("canvas")?.getContext('2d') as CanvasRenderingContext2D

        context.canvas.height = 180;
        context.canvas.width = 320;

        // define the propteries and dimesion of the rectangle

        let rectangle = {
            height: 32,
            width: 32,
            // we have access to this prop so when it's jumping we define 
            // flase in the air
            jumping: true,
            x_velocity: 0,
            x: 144, // on the ground
            y_velocity: 0,
            y: 0,
        }

        // now let's merge the controller logic with the physics

        const loop = function() {
          // wall detection

          // we have to give the canvas gray filling
          context.fillStyle = '#202020';
          // This erases the color behind and around the square, because it
          // didn't we will get a contiouns stroke
          context.fillRect(0, 0, 320, 180);
          // This keeps the rectangle stroking the canvas
          context.fillStyle = "#ff0000";// hex for red
          context.beginPath();
          // the dimessional of the rectangle
          context.rect(rectangle.x, rectangle.y, rectangle.width, rectangle.height);
          context.fill();

          context.strokeStyle = "#202020";
          context.lineWidth = 4;
          context.beginPath();
          context.moveTo(0, 164);
          context.lineTo(320, 164);
          context.stroke();

          socket.emit('object', {
            rectangle
          });

          socket.on('assignObj', obj => {
            rectangle = obj.rectangle
            console.log(rectangle)
          })

          window.requestAnimationFrame(loop);
        }

        /* window.addEventListener('keyup', (e) => {
            socket.emit('object', {
              rectangle,
              keyCode: e.keyCode,
              type: e.type
            })
        }) */

        /* window.addEventListener("keydown", (e) => {
          socket.emit('control', { 
            keyCode: e.keyCode,
            type: e.type
           })
          socket.on('emitControl', e => {
            controller.keyListener(e)
          })
        });
        window.addEventListener("keyup", (e) => {
          socket.emit('control', { 
            keyCode: e.keyCode,
            type: e.type
           })
          socket.on('emitControl', e => {
            controller.keyListener(e)
          })
        });
        */

        window.requestAnimationFrame(loop); 

      })

  }, [])

  return <div>
    { typeof window && <canvas></canvas> }
  </div>


users.push({ id: socket.id, rectangle: {
                height: 32,
                width: 32,
                jumping: true,
                x_velocity: 0,
                x: 144, // on the ground
                y_velocity: 0,
                y: 0,
            } });

            socket.emit('assignRect', users.slice(-1)[0]);
            

            socket.on('object', obj => {
                
                const controller = {

                    left: false,
                    right: false,
                    up: false,
                    keyListener: function (event: any) {
                        // state of the key
          
                        let key_state = (event.type == "keydown") ? true : false;
                        console.log(event.keyCode)
          
                        switch(event.keyCode) {
          
                            case 37: // left key
                            controller.left = key_state;
                            break;
                            case 38: // up key
                            controller.up = key_state;
                            break;
                            case 39: // right key
                            controller.right = key_state;
                            break;
          
                        }
                    }
          
                  }


                if(controller.up && obj.rectangle.jumping == false) {
                    obj.rectangle.y_velocity -= 20;
                    obj.rectangle.jumping = true;
                }
      
                // left controlloer input
                if(controller.left) {
                    obj.rectangle.x_velocity -= 0.2;
                }
      
                // right controller input 
                if(controller.right) {
                    obj.rectangle.x_velocity += 0.2;
                }
      
                // physics
      
                // velocity is 1.5 every frame
                obj.rectangle.y_velocity += 0.4; // gravity of the canvas
                obj.rectangle.x += obj.rectangle.x_velocity;
                obj.rectangle.y += obj.rectangle.y_velocity;
      
                // friction -> slow gradually
      
                obj.rectangle.x_velocity *= 0.9;
                obj.rectangle.y_velocity *= 0.9;
      
                // ground detection
      
                if ( obj.rectangle.y > 180 - 16 - 32 ) {
      
                    obj.rectangle.jumping = false;
                    obj.rectangle.y = 180 - 16 - 32;
      
                    // once the obj.rectangle hits the ground, your veclocity should stop
                    // instantly
                    obj.rectangle.y_velocity = 0;
      
                }

                socket.emit('assignObj', obj)
            }) 

           /* socket.on('control', e => {
               console.log(e)
               socket.emit('emitControl', e)
           }); */